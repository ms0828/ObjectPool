# 오브젝트 Pool과 Free List

- **Pool**
    - 미리 만들어 놓고 원할 때 가져다가 쓰고 다시 반환하는 방식
    - 할당과 해제 과정을 생략하기 위해 미리 만들어 놓은 것
    - 속도를 위해서 쓰는 것
        - 내/외부 단편화 방지의 목적으로도 사용하는 것도 있으나 속도가 가장 주된 요인임
- **Free List**
    - 미리 만들어 놓진 않지만 사용하지 않는 것을 리스트에 반환하여 재사용

**[ 풀과 프리 리스트의 차이점은? ]**

- 사용이 끝난 자원을 반납하여 재사용 하는 것은 똑같다.
- **그러나 초기에 미리 만들어 놓는지, 필요할 때 할당받아 사용하는지의 차이가 존재**
- **따라서 풀의 초기 확보량까지의 싸이클이 돈 시점 부터는 프리 리스트와 풀은 차이가 없다.**

**[ 서버에는 어떤 것이 더 좋을까? ]**

- 풀은 초기 할당 시 조금 느려지나 런타임에는 빠르게 동작할 것
    - 그러나 초기 확보량 만큼 실제 사용하지 않는다면 메모리 낭비가 있을 것임
- 따라서 메모리(오브젝트)초기 확보량이 명확하다면 풀을 선택하는 것이 좋다.
- 그러나 메모리(오브젝트) 초기 확보량 판단이 애매하다면?
    - 프리 리스트도 결국 한 싸이클이 돌게 되면 풀과 비슷해지므로 선택해도 나쁘지 않다.
        - 대신 첫 싸이클에는 조금 느려질 것임

> 생성자에 초기 할당량을 넣으면 풀 , 아니면 프리 리스트 형태가 되게끔 구현 예정


## 메모리 풀(프리 리스트) vs 오브젝트 풀(프리 리스트)

**[ 메모리 풀을 만들 것인가 오브젝트 풀을 만들 것인가 ]**

메모리 풀을 만들면 malloc/free 대신 내가 만든 메모리 풀(메모리 관리자)/을 사용하겠다는 것인데..

- 힙도 페이지 단위로 확보해가면서 그 공간을 블럭으로 나누어 주는 것
    - 우리가 힙보다 더 빠르게 잘 만들 수 있을까?
    - 그리고 실 사용에서 “몇 바이트 메모리가 필요하다.” 라는 식은 거의 없다.
        - 대부분 객체 타입 만큼의 메모리가 필요한 것
        - 심지어 버퍼가 필요하다 해도 버퍼를 객체화해서 객체를 생성 하는게 일반적..
- 메모리 풀보다 오브젝트 풀이 활용도가 좋다.
- **그리고 오브젝트 풀을 사용하면 객체 별로 메모리 사용량을 모니터링 할 수 있으며 추적이 쉽다.**
- 또한 풀은 사용할 때 페이지 새로 할당없음. 그러나 프리 리스트는 할당만 계속 반복되면 힙과 똑같이 페이지 할당 가능



# 오브젝트 풀(프리 리스트)

```cpp
ObjectPool<T>
```

특정 타입 하나를 관리하는 풀(프리 리스트)

- 오브젝트 타입 마다 모두 선언해야 한다.
    - 클라는 종족, 종류, 상속 관계마다 전부 클래스가 다르게 나온다. 그러나 서버 입장에서는 상속을 잘 쓰지 않는다. 종족, 종류와 상관없이 똑같은 플레이어, 몬스터이다. 이런 것들은 클래스로 나뉘지 않고 내부 변수 값이 달라지는 것. 이런걸 생각해보면 타입이 그렇게 많지 않다.
    - 따라서 템플릿을 사용해도 큰 단점이 없다.

## 오브젝트 풀 사용의 장점 ★★★

사실 new delete도 4K 페이지 단위로 할당하고 거기서 블럭을 나누어 주는 것

그럼 왜 new delete가 아닌 풀을 사용하는가?

1. **속도**
    - **힙이 느린 이유는 페이지를 새로 할당할 때와 멀티 스레드 환경에서 동기화를 걸기 때문에 느린 것**
        - **힙 블럭 할당은 멀티 스레드 환경을 대비한 동기화(락)이 존재**
        - **사실 아래 장점이 큰 것이기 때문에 지금 구현한 오브젝트 풀이 힙 보다 그렇게 빠르진 않을 것임**
        
        
2. **메모리 누수 찾기에서의 이점 ★★★**
    
    **[ 만약 new delete를 썼다면 메모리 누수를 어떻게 판단하겠는가? ]**
    
    - 메모리 사용량이 올라가는 것으로 확인할 수 있을 것
        - 우리가 new/delete 오버로딩 구현한 것은 테스트 할 때만 사용할 수 있음 (느려서)
    - new delete 사용하다 메모리 누수가 났다면 코드 뒤지는거 말고 할 수 있는게 없다.
    - 미세하게 증가하는 거라면 코드에서 찾는 것도 매우 힘듬
    
    **[ 메모리 사용량을 세부적인 오브젝트 풀 사용량으로 조사하면 누수를 찾기 쉽다. ]**
    
    - **풀을 사용하면 풀 사용량을 객체 별로 모니터링 할 수 있다.**
    - **메모리가 증가하고 있다면 어떤 풀이 증가하는지 보면 된다.**
    - **누수를 찾기가 매우 쉽다.**
    - **또한 객체 별로 메모리를 관리하기 때문에 추적이 쉽다.**

## 풀의 자료구조 선택

**[ 가장 무식하게 배열을 사용한다면 ]**

1. 내부 풀(버퍼)를 초기 할당량 크기만큼 배열로 만든다.
2. bool 배열을 별도로 두어 사용 여부를 유지한다. 
3. Alloc에서 사용중이지 않는 공간을 반환한다.
    - 저장된 오브젝트 개수와 상관없이 똑같은 시간으로 가용 공간을 바로 찾으려면?
    - 가용 인덱스를 관리하는 별도의 스택이나 큐를 이용한다.

**[스택 vs 큐 ]**

- 방금 썼던 걸 또 쓰는 것이 캐시 히트율을 높일 수 있고 페이지 폴트 확률을 줄일 수 있다.
- 따라서 큐 보단 스택을 사용한다.

**[ 배열로 오브젝트 풀을 구현한다면 크기 확장에 제한이 있을 것이다. ]**

- **결국 가변적인 형태를 띄려면 리스트 형태를 가야한다.**
    
    

### 리스트 + Stack을 이용한 ObjectPool

**[ stl::stack을 사용할 수 없다. ]**

- ObjectPool 구현 목적은 new /delete보다 훨씬 빠른 동작을 원하는 것
    - 힙 할당은 내부적으로 동기화를 수행하기 때문에 new delete가 느리기 때문
    - 풀을 사용하는 목적은 사용할 때 마다 동적 할당을 하지 않겠다는 것
- 그러나 std::stack은 new / delete와 마찬가지로 내부에서 힙 관리자의 개입이 일어난다.
    - 힙 관리자를 안쓰려고 풀을 구현하는 것인데, stl::stack을 쓰면 힙에 의존하는 형태가 된다.

> **동적할당 받은 오브젝트를 관리하기 위한 자료구조가 힙 관리자에 의존하게 되면 의미가 없어진다.**
> 
> - **따라서 스택을 구현한 리스트의 push, pop과정에서 힙 관리자의 개입이 없어야한다.**

**[ 수정사항 ]**

> stl stack은 기본 컨테이너인 deque를 사용했을 시, 내부를 list가 아니고 고정 크기 블럭으로 유지하게 된다. (이 블럭을 map으로 관리한다고 함..?) (확실하지 않으므로 검증해봐야함)
> 
> - 그래도 힙 관리자에 의존하는 형태가 되는 것은 마찬가지

# Intrusive List를 활용한 할당 및 반납

### 노드를 관리하는 리스트에서 동적 할당을 어떻게 없앨 것인가?

- 일반적인 동작을 생각하면 Alloc()을 하면 T*를 가져오고, 해당 Node는 삭제
    - 다시 FreeObject()를 하면 T*를 담을 빈 껍데기가 필요하므로 빈 껍데기 Node를 또 생성
    - 이렇게 구현하면 new, delete가 필요하므로 오브젝트 풀을 만들 이유가 없다.
- **intrusive list(침습성 리스트)**
    - **사용자에게 할당하는 오브젝트가 리스트의 연결 정보 등을 포함하도록 설계**
        - **데이터가 곧 노드가 되도록 설계하며 사용자에게는 노드를 주는 것**
    - **노드가 데이터를 포인터로 가지지 않고 데이터 그 자체를 가진다.**
        - **별도의 메모리 공간이 아니라 한 덩어리로 취급한다.**
- **노드가 별도의 데이터를 관리하지 않으므로 동적 할당 없이 빠른 삽입과 삭제가 가능하다.**
    - non-intrusive는 메모리와 별도의 노드를 따로 관리해야하므로 Node의 동적할당이 발생

> **정리하면 데이터를 관리할 노드와 데이터를 따로 관리하지 않고, 노드가 데이터 자체를 들고있으므로 데이터를 하나의 노드로써 관리한다는 것**
> 

**[ intrusive list 라면 T*가 아닌 T를 유지해야 한다.]**

- **사용자에게 T를 할당하면 노드를 주고, 반납할 때 T를 반납하면 노드가 반납되는 형식**
- **AllocObject, FreeObject는 T의 포인터를 주고 받음으로써 노드를 주고 받는 모습이 된다.**
    - AllocObject, FreeObject이 T를 주고 받는다면 문제가 무엇인가?
        - 복사하여 전달하므로 노드를 주는게 아니게 된다.
        - 그럼 이를 해결하려면 AllocObject, FreeObject등에서 T의 포인터를 받으면 된다.
            - ObjectFreeList<T> 이지만 T* AllocObject, bool FreeObject(T*)
- **결국 사용자에게 T*를 주면 사용자와 노드를 주고 받는 형태가 된다.**
    - 힙 할당에도 사용할 메모리의 주소를 받으나, 이 공간 앞 뒤로 힙 메타 데이터가 들어가는 것 처럼…

### 노드 내부 객체를 하나씩 관리할 것인가? 배열 덩어리로 여러개씩 관리할 것인가?

**[ 노드 당 하나의 객체 배열 덩어리로 연결된 리스트 vs 노드 당 하나의 객체로 연결된 리스트 ]**

- 캐시히트률 관점에서 살펴본다면

배열로 연속적인 공간에 할당했을 때 초반에 캐시 히트율은 어느정도는 영향이 있으나, 할당과 해제를 반복하다보면 결국 뒤 섞이기 때문에 큰 의미가 없을 것이다. (풀에서 뽑아 사용하고있는 오브젝트들을 순회하는데 이 들이 이 한 페이지에 전부 들어갔다면 메모리 주소의 인덱스 충돌이 없으므로 효과를 볼 것이다.)

> 당연히 way를 고려하면 한 페이지 보단 넓은 범위가 담기겠지만, 인덱스 충돌 관점에서만 보면 한 페이지 크기가 가장 효과가 좋을 것
> 
- 효과가 없는건 아니지만 메모리를 붙여 놓은거 보다 어떻게 사용하는지에 따라 캐시 히트률에 더 영향이 있으므로 효과가 크지는 않을 것이다.
- 게다가 배열 덩어리를 만들어 블럭으로 쪼개쓴다면 관리할 블럭 정보가 리스트가 또 나와야함
    - 하나씩 연결된 리스트가 더 좋을거 같다..
    - 캐시 히트율도 사실상 결국은 섞이니까 큰 영향은 없을 것이다.

# 오브젝트 풀(프리 리스트) 구현 시 고려사항

## 풀이 비어있을 때 정책

- 개수 제한이 있으면 nullptr 반환
- 개수 제한이 없으면 안에서 생성해서 반환

## 오브젝트 반납 시 올바른 노드인지 검증

```cpp
freeObject(T* objectPtr);
```

**[  objectPtr을 반납할 풀이 자신이 할당 받은 풀이 맞는가? ]**

- 잘못된 포인터면 어떻게 할 것인가? 그리고 잘못된 포인터인지 어떻게 알 수 있는가?
- 노드에 메타데이터를 넣는다.
    - 그 객체의 오브젝트 풀이 맞는지 확인하기 위해 ObjectPool의 instance가 생성될 때마다 pool에 대한 고유 값이 나와야 할 것

## **메모리 언더플로 오버플로 체크**

- 노드의 메타데이터 등으로 앞, 뒤 (cdcd 등)으로 메모리 침범을 확인하는 기능
- 반납할 때 확인

## 오브젝트 풀의 소멸 정책

- 물론 풀이 중간에 소멸할 일은 없지만 그냥 클래스를 만드는 입장에서 고려한다면 어떤 정책을 세울까?
- 누군가 오브젝트를 할당받았다면 오브젝트 풀 입장에서 해당 노드의 정보가 없다.
- 자신이 가지고 있는 것만 해제할 것인가? 아니면 자기가 만든 모든 걸 찾아서 해제할 것인가?
    - 후자라면 내부에 오브젝트(노드) 모두를 따로 관리하여야 할 것임

> 현재 자신이 가지고 있는 오브젝트만 해제하도록 구현하였음
> 

## 속도에 대한 고려

ObjectPool에 안전 장치를 넣으면 넣을수록 속도가 느려질 것이다.

- ObjectPool 구현 목적대로 new delete 보단 빨라야한다.
    - 코드가 몇 줄 밖에 없으므로 몇 개의 명령어 개수 차이로 성능이 갈릴 것이다..
- 전처리기로 안전장치를 넣을 것이냐 말 것이냐를 결정하는 방법을 선택
    - 개발 환경에서는 안전장치를 추가해놓고 서비스 할 때는 안전장치를 제거

> 실제 서버 서비스에서 이를 써도 사실 크게 바뀌지 않는다. 애초에 동적할당할 일이 많지 않으므로
> 

## 객체(오브젝트)의 생성자 호출 정책 ★★★

- 제네릭 타입이 클래스라면 일정 메모리 공간이 아니라 객체로 나와야한다.
    - 즉, 풀에서 객체를 할당받을 때 생성자 호출이 되어야한다.
- allocObject()할 때 playcement new를 사용하여 생성자 호출한다.
    - new (allocNode) T();

**[ 객체가 자신의 생성자에서 동적할당을 하지 않는 경우 ]**

- 멤버 변수 초기화 등의 작업만 있는 경우
- allocObject()를 할 때 마다 해당 객체의 생성자를 호출한다.

**[ 객체가 자신의 생성자에서 동적할당을 하는 경우 ]**

- 오브젝트 풀 내부에서 객체가 만들어 질 때 한 번만 생성자를 호출한다.
- 반납 후 해당 객체를 재사용할 때 해당 객체가 사용하는 또 다른 객체를 반드시 초기화하여야함!
    - 직렬화 버퍼(객체) 같은 경우 자신의 버퍼를 계속 재사용하므로 allocObject()를 할 때마다 어플리케이션 로직 차원에서 직렬화 버퍼의 Clear()를 호출해줘야함

## 객체(오브젝트)의 소멸자 호출 정책 ★★★

**[ 객체가 자신의 생성자에서 동적할당을 하지 않는 경우 ]**

- 반납(FreeObject)할 때 마다 소멸자가 호출되어야한다.
    - 객체 포인터→~T();

**[ 객체가 자신의 생성자에서 동적할당을 하는 경우 ]**

- 오브젝트 풀이 소멸할 때만 소멸자가 호출 되어야한다.

> 제네릭 타입(객체)가 레퍼런스(동적할당)을 가지고 있는지에 대한 여부를 인자로 넘김으로써, 풀 인스턴스 자체에 할당과 반납 동작(생성자, 소멸자 호출) 방법이 정해지도록 사용
> 

## 객체(오브젝트)의 생성자 인자 전달

그럼 인자가 있는 생성자는 어떻게 호출?

- 모던 c++에 있는 가변인자 템플릿을 사용하면 가능하다.

### 가비지 콜렉터 (선택사항)

**[ 오브젝트 풀의 할당량이 늘어났으나 오랜 기간 동안 사용되지 않아 페이지 아웃이 되었다면? ]**

- 이 때는 가비지 컬렉터를 구현하여 사용 중인 메모리를 어느정도 반납 하는 것도 고려
- 만약에 페이지 아웃이 되었다면 그냥 새로 동적할당을 받는 것이 더 빠를 수도 있다.

> 지금 말하는 가비지 콜렉터는 c#의 가비지 콜렉터랑 맥락이 조금 다름
> 
- 풀에서 오랜기간 사용되지 않는 오브젝트의 메모리 반납(free) 기능
- 전체 확보량, 사용 중인 카운터를 유지할 것이므로 이를 보고 오랜기간 사용되지 않는 메모리를 판단
    - freeObject()가 호출될 때 판단
        - 최대 사용량으로 판단
    - **힙도 그러고 있음**
        - **얼마만큼 사용했던 적이 있는지를 기준으로 커밋된 페이지 크기를 가변적으로 조절**
    
    > **[ 나중에 힙과 메모리 풀 테스트하며 비교할 때 고려사항 ]**
    힙은 갈수록 빨라지기 때문에 빨라진 시점(디커밋을 안하는 시점)에 비교를 해야 할 것임
    → 내가 구현한 프리 리스트 또한 한 싸이클이 모두 돌고난 후에 비교
    > 

**무조건 테스트 해봐서 new delete보다 빠른지 확인할 것**

- **안하면 의미가 없음**

---

# 메모리 풀(프리 리스트) (선택 사항)

malloc , free의 대용

- 오픈소스 라이브러리가 있긴 함 (jmalloc, tcmalloc)
    - 더 빠른 malloc
        - 프리 리스트 방식으로 기존 힙을 래핑한 것임

```cpp
p1 = Alloc(200);
p2 = Alloc(3000);
Free(p1);
Free(p2);
```

## 어떻게 구현할 것인가?

- 할당 받았던 고정 크기 블럭들이 별도의 프리 리스트로 관리되어야 한다.
    - Free(p)를 하게 되면 p로써 특정 크기에 대한 프리 리스트를 찾을 수 있어야함
    - 크기가 섞이면 결국 찾아야하는데, 해당 크기 블럭을 찾는데 오래 걸리기 때문에
- 아래와 같은 고정된 크기(예시)의 프리 리스트를 사용
    - 70을 요구하면 100을 준다
    - 150을 요구하면 200을 준다.

> 힙도 사실 첫 할당 이후부터는 각자의 규격(크기)의 리스트로 관리된다.
> 
> 
> **사용자가 힙에서 요구한 크기가 힙의 관리 크기를 넘어서면 그냥 virtualAlloc으로 크게 준 다음에 통으로 날림 → 이 때는 재사용 안됨**
>